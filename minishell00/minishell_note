
Bibliotheques necessaires :

#include <readline/readline.h> //Pour les fonctions de readline
#include <stdio.h>      // Pour printf
#include <stdlib.h>     // Pour malloc, free, exit
#include <string.h>     // Pour strerror
#include <unistd.h>     // Pour access, write, close, fork, execve, dup, dup2, pipe, getcwd, chdir, isatty, ttyname
#include <sys/types.h>  // Pour wait, waitpid, wait3, wait4, signal, stat, lstat, fstat, unlink, opendir, readdir, closedir
#include <sys/wait.h>   // Pour wait, waitpid, wait3, wait4
#include <sys/stat.h>   // Pour stat, lstat, fstat
#include <fcntl.h>      // Pour open
#include <signal.h>     // Pour signal, sigaction, sigemptyset, sigaddset, kill
#include <termios.h>    // Pour tcsetattr, tcgetattr
#include <curses.h>     // Pour tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs
#include <dirent.h>     // Pour opendir, readdir, closedir
#include <sys/ioctl.h>  // Pour ioctl
#include <pwd.h>        // Pour getpwnam
#include <errno.h>      // Pour errno
==================================================================

Command	Description :
(source: https://github.com/maiadegraaf/minishell/tree/main)

=>cd : with only a relative or absolute path
--------------------------------------------
Changes the working directory of the current shell execution environment and updates the environment variables PWD and OLDPWD.
Without arguments it change the working directory to the home directory.
il faut gerer '-' le tiret <=> cd "$OLDPWD" && pwd
remarque :
s'il y a plus d'1 arguments => bash: cd: too many arguments + $? = 1
tout au debut $HOME = $PWD = $OLDPWD
. | ././././ <=> dossier courant
../ <=> dossier parent du dossier courant
/ <=> dossier racine 


=>echo : with option -n
-----------------------
Displays a line of text
Optional flag -n: do not output the trailing newline
remarque : code de sortie de echo
0 -> succes
>0 -> erreur


=>env : with no options or arguments
------------------------------------
Displays the environment variable
remarque: code de sortie de env
0 -> succes
>0 -> erreur
126 ->env a été trouvée mais n'a pas pu être exécutée
127 ->n'a pas pu être exécutée


=>exit : with no options
------------------------
Terminates the shell.
Accepts optional argument n, which sets the exit status to n.

$? Code de sortie souvent apparu :
0 : execution qui se termine normalement sans erreur -> ex: exit (sans argument)
1 : erreur generique sans preciser sa nature -> ex: exit 758 hgfj hgfj (plus d'1 arg)
2 : syntax error -> ex: exit ghfj gfh fghj (pas arg numerique)
126 : le système d'exploitation n'a pas pu trouver l'exécutable spécifié ou n'a pas pu le lancer en raison de restrictions de sécurité
127 : command not found 
130 : termine en raison de l'interruption de l'utilisateur (ctrl+c)
131 : termine en raison de l'interruption de signal (ctrl+v)
$? = exit_code % 256


=>export : with no options
--------------------------
Accepts arguments name[=value].
Adds name to the environment. Set's value of name to value.
If no argument is given, displays list of exported variables.
remarque : 
export test -> ajoute test dans la liste d'export MAIS pas d'env
export test= -> ajoute test dans la liste d'export ET d'env
donc seule une variable definit suivi de "=" avec ou sans valeur(meme si vide)

!BUG pas encore regle: segfault si on enleve/modifier le premier var de la list.

=>pwd : with no options
-----------------------
Shows the current directory as an absolute path.
pwd suivi de d'autres cmd ou mots, le chemin s'affiche quand meme ET pas msg d'erreur
ex: pwd pwd ls : le chemin s'affiche qu'une seule fois 
remarque : 
si on unset la var d'env PWD et on execute pwd, le chemin s'affiche quand meme


=>unset : with no options
-------------------------
Accepts argument name.
Removes the variable name from the environment.
remarque :
si l'argument a supprimer n'existe pas unset ne signale pas d'erreur,
et se termine normalement.
Si l'argument est "name=", name ne sera pas supprimer et unset ne signale pas d'erreur.


==================================================================
Tests deja effectues (sous bash) :

=> echo :
BingdeMBP:srcs bing$ echo

BingdeMBP:srcs bing$ echo -n
BingdeMBP:srcs bing$ echo -nnnnnnnn
BingdeMBP:srcs bing$ echo -n -n-n
-n-nBingdeMBP:srcs bing$ echo -n -n -n
BingdeMBP:srcs bing$ echo hello
hello
BingdeMBP:srcs bing$ echo -n hello
helloBingdeMBP:srcs bing$ echo -n hello world
hello worldBingdeMBP:srcs bing$ 
	
=> env :
valgrind env -i env
valgrind env

=> export + unset:
int	main(int argc, char **argv, char **env)

	t_list	*envlist;
	t_list	*explist;

	envlist = NULL;
	explist = NULL;
	printf("teste : %d %s\n", argc, argv[0]);
	envlist = env_to_envlist(env);
	explist = env_to_envlist(env);

	printf("print env list : \n");
	ft_env(envlist);
	printf("\n\n");
	ft_export(&envlist, &explist, "test");
	printf("\n\n");
	ft_export(&envlist, &explist, "test1=");
	ft_export(&envlist, &explist, "test2");
	ft_export(&envlist, &explist, "LSCOLORS=test");
	ft_export(&envlist, &explist, "USER=test");
	ft_export(&envlist, &explist, "SHELL=test");
	ft_export(&envlist, &explist, "LOGNAME=test");
	ft_export(&envlist, &explist, "TERM_PROGRAM=");
	ft_export(&envlist, &explist, "test3=");
	ft_export(&envlist, &explist, "test");
	ft_unset(&envlist, &explist, "test");
	ft_unset(&envlist, &explist, "test1=");
	ft_unset(&envlist, &explist, "te");
	ft_unset(&envlist, &explist, "SHELL");
	ft_env(envlist);
	printf("\n\n");
	ft_unset(&envlist, &explist, NULL);
	ft_export(&envlist, &explist, NULL);
	free_list(&envlist);
	free_list(&explist);
	return (0);

=================================================================
Pour ignorer les leaks causes par readline et add_history :

creer un ficher de suppression(ex : ignoreleak.supp) avec le contenu

{
    readline
    Memcheck:Leak
    ...
    fun:readline
}
{
    add_history
    Memcheck:Leak
    ...
    fun:add_history
}

lors de l'execution du programme :
executer 	valgrind --suppressions=ignoreleak.supp ./leProgramme

==================================================================
Execution :




==================================================================
Parsing :

-traiter les quotes.
-remplacer $(var) par sa valeur
-verifier la syntaxe des variable d'env :
	 elles ne peuvent commencer soit par des LETTRES soit le TIRET DU BAS,
	 les caracteres ALPHANUMERIQUE sont autorises a utiliser.
-$(var) : is var n'existe pas, une chaine vide sera envoye.
-En Bash, le point d'exclamation est réservé pour les événements (history expansion)
	et provoque l'interprétation de l'expression qui suit comme une référence à un 
	événement de l'historique

==================================================================
bash man : note

-le code de retour de bash est celui de la derniere commande executee, il sera stocke dans $?.
-bash attend la fin de toutes les commandes avant d'envoyer une valeur.
-Chaque commande du pipeline est exécutée comme un processus indépendant (c'est-à-dire dans un sous-shell).
-Les expansions sont appliquées à la ligne de commande après qu'elle ait été divisée en mots.
-Les fonctions interne renvoient zéro (vrai) si elles réussissent et une valeur non nulle (faux)
 si une erreur se produit durant leur exécution. Toutes les fonctions internes renvoient 2 en cas d'erreur de syntaxe.


